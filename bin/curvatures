#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar  7 22:36:30 2025

@author: winkleram
"""

import argparse
import numpy as np
import nibabel as nib

def read_obj(filein): # =======================================================
    '''
    Open and parse a Wavefront OBJ file.
    Handles all standard face formats and returns texture/normal indices.
    
    Parameters:
    filein (str): Path to the OBJ file
    
    Returns:
    dict: Dictionary containing vertices, normals, texture coordinates, and faces
          with their respective vertex, texture, and normal indices
    '''
    v  = []
    vt = []
    vn = []
    f  = []
    ft = []
    fn = []
    with open(filein, 'r') as fp:
        for line in fp:
            if line.startswith('#'):  # Skip comments
                continue
            values = line.split()
            if not values:
                continue
            if values[0] == 'v':     # Vertex coordinates
                v.append([float(x) for x in values[1:4]])
            elif values[0] == 'vt':  # Texture coordinates
                vt.append([float(x) for x in values[1:3]])
            elif values[0] == 'vn':  # Normals
                vn.append([float(x) for x in values[1:4]])
            elif values[0] == 'f':  # Face
                vidx  = []
                vtidx = []
                vnidx = []
                for val in values[1:]:
                    idx = val.split('/')
                    vidx.append(int(idx[0]) - 1)
                    if len(idx) > 1 and idx[1]: # Texture coordinate index
                        vtidx.append(int(idx[1]) - 1)
                    else:
                        vtidx.append(None)
                    if len(idx) > 2: # Normal coordinate index
                        vnidx.append(int(idx[2]) - 1)
                    else:
                        vnidx.append(None)
                f.append(vidx)
                ft.append(vtidx)
                fn.append(vnidx)
            elif values[0] == 's':
                continue
    obj = {
        'v':  np.array(v),   # Vertex coords
        'vt': np.array(vt),  # Vertex texture
        'vn': np.array(vn),  # Vertex normal
        'f':  np.array(f),   # Face indices (refer to v)
        'ft': np.array(ft),  # Face texture indices (refer to vt)
        'fn': np.array(fn)   # Face normal indices (refer to vn)
    }
    return obj

def write_curv(fileout,k,kd):
    '''
    Parameters
    ----------
    fileout : String
        Filename of the output.
    k : NumPy vector
        Curvature (e.g., k1, k2 vertexise).
    kd : NumPy array with 3 columns.
        Direction of the curvature.

    Returns
    -------
    None.

    '''
    nvtx = k.shape[0]
    idx = np.arange(0,nvtx)[:,None]
    data = np.concatenate((idx,kd,k[:,None]), axis=1)
    np.savetxt(fileout, data, fmt='%d %f %f %f %f')
    return

def calc_normals(vtx, fac): # =================================================
    '''
    Compute vertex normals for a mesh using Nelson Max's weighting method.
    
    Parameters:
    - vtx: numpy array of shape (nvtx, 3), coordinates of vertices
    - fac: numpy array of shape (nfac, 3), vertex indices for each face
    
    Returns:
    - vn : ndarray (nvtx, 3), normals per vertex
    - fn : ndarray (nfac, 3), normals per face
    '''
    # Number of vertices and faces
    nvtx = vtx.shape[0]
    nfac = fac.shape[0]
    
    # Allocate to accumulate vertex normals
    vn = np.zeros((nvtx, 3))
    fn = np.zeros((nfac, 3))
    
    # For each face
    for f in range(nfac):
        
        # Vertices and edges of the current face
        vA = vtx[fac[f,0]]
        vB = vtx[fac[f,1]]
        vC = vtx[fac[f,2]]
        eA = vC - vB  # V_{i}
        eB = vA - vC  # V_{i+1} for vA
        eC = vB - vA  # V_{i+1} for vB when cycling back
                
        # Edge lengths
        len_eA = np.linalg.norm(eA)
        len_eB = np.linalg.norm(eB)
        len_eC = np.linalg.norm(eC)
        
        # Face normal
        fn[f,:] = np.cross(eC, eA)

        # Angles at each vertex, clip to avoid numerical problems
        cos_alphaA = np.clip(np.dot(eC, -eB) / (len_eC * len_eB), -1.0, 1.0)
        cos_alphaB = np.clip(np.dot(eA, -eC) / (len_eA * len_eC), -1.0, 1.0)
        cos_alphaC = np.clip(np.dot(eB, -eA) / (len_eB * len_eA), -1.0, 1.0)
        alphaA     = np.arccos(cos_alphaA)
        alphaB     = np.arccos(cos_alphaB)
        alphaC     = np.arccos(cos_alphaC)
        
        # Weights -- Equation 2 of Max (1999), i.e., sin(alpha) / (|V_i| * |V_{i+1}|)
        cA = np.sin(alphaA) / (len_eB * len_eC)
        cB = np.sin(alphaB) / (len_eA * len_eC)
        cC = np.sin(alphaC) / (len_eA * len_eB)

        # Accumulate weighted face normal contributions
        # thus avoiding to iterate over vertices
        vn[fac[f,0]] += cA * fn[f]
        vn[fac[f,1]] += cB * fn[f]
        vn[fac[f,2]] += cC * fn[f]

    # Normalize normals to unit norm
    vn  /= np.linalg.norm(vn, axis=1)[:,None]
    fn  /= np.linalg.norm(fn, axis=1)[:,None]
    return vn, fn

def calc_voronoi_areas(vtx, fac): # ===========================================
    '''
    Compute the Voronoi area for each vertex of each triangular face in a mesh.
    
    Parameters:
    - vtx: numpy array of shape (nvtx, 3), coordinates of vertices
    - fac: numpy array of shape (nfac, 3), vertex indices for each face
    
    Returns:
    - vorv: numpy array of shape (nvtx, 1), Voronoi areas for each vertex
    - vorf: numpy array of shape (nfac, 3), Voronoi areas for each vertex of each face
    '''
    # Number of vertices and faces
    nvtx = vtx.shape[0]
    nfac = fac.shape[0]
    
    # Allocate to store Voronoi areas, per vertex and per vertex of each face
    area = np.zeros(nfac)
    vorv = np.zeros(nvtx)
    vorf = np.zeros((nfac, 3))
    
    # For each face
    for f in range(nfac):
        
        # Vertices and edges of the current face
        vA = vtx[fac[f,0]]
        vB = vtx[fac[f,1]]
        vC = vtx[fac[f,2]]
        eA = vC - vB  # V_{i}
        eB = vA - vC  # V_{i+1} for vA
        eC = vB - vA  # V_{i+1} for vB when cycling back
                
        # Edge lengths
        len_eA = np.linalg.norm(eA)
        len_eB = np.linalg.norm(eB)
        len_eC = np.linalg.norm(eC)

        # Angles at each vertex, clip to avoid numerical problems
        cos_alphaA = np.clip(np.dot(eC, -eB) / (len_eC * len_eB), -1.0, 1.0)
        cos_alphaB = np.clip(np.dot(eA, -eC) / (len_eA * len_eC), -1.0, 1.0)
        cos_alphaC = np.clip(np.dot(eB, -eA) / (len_eB * len_eA), -1.0, 1.0)
        alphaA     = np.arccos(cos_alphaA)
        alphaB     = np.arccos(cos_alphaB)
        alphaC     = np.arccos(cos_alphaC)
        
        # Area of the entire face
        area[f] = np.linalg.norm(np.cross(eA, eB))/2

        # Voronoi area for each vertex of a face
        # Voronoi area = (angle / sum of angles) * area
        vorA     = area[f] * alphaA / np.pi
        vorB     = area[f] * alphaB / np.pi
        vorC     = area[f] * alphaC / np.pi
        vorf[f,:] = [vorA, vorB, vorC]
        
        # Accumulate vertex Voronoi areas for faces that meet at that vertex
        for v in range(3):
            vorv[fac[f,v]] += vorf[f,v]
    return vorv, vorf, area

def calc_rot(n): # ============================================================
    '''
    Compute a 3x3 rotation matrix that changes the coordinate system such
    that n @ rot is a new coordinate system with the z-axis along n.

    Parameters
    ----------
    n : Input vector, already with norm = 1

    Returns
    -------
    rot : Rotation matrix
    '''
    n     /= np.linalg.norm(n)
    z      = np.array([0,0,1])
    axis   = np.cross(z,n)
    naxis  = np.linalg.norm(axis)
    if naxis > 0:
        axis  /= naxis
    angle  = np.arccos(np.clip(np.dot(z,n),-1,1))
    K = np.array([
        [   0 ,    -axis[2],  axis[1]],
        [ axis[2],       0 , -axis[0]],
        [-axis[1],  axis[0],       0]])
    rot    = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)
    return rot

def calc_curvatures(vtx, fac, vtxn, facn, vorv, vorf): # ======================
    # Number of vertices and faces
    nvtx = vtx.shape[0]
    nfac = fac.shape[0]
    
    # Precompute transforms from the global to local coordinate system of each vertex
    rotv = np.zeros((3,3,nvtx))
    for v in range(nvtx):
       rotv[:,:,v] = calc_rot(vtxn[v])
    
    # Allocate space to store the Weingarten matrix for each vertex
    IIv = np.zeros((2,2,nvtx))
    
    # Allocate soace to store k1, k2, and the directions kd1 and kd2
    k1  = np.zeros(nvtx)
    k2  = np.zeros(nvtx)
    kd1 = np.zeros((nvtx,3))
    kd2 = np.zeros((nvtx,3))

    # For each face
    for f in range(nfac):

        # Transformation from the global the local coordinate system of this face
        rotf = calc_rot(facn[f])

        # Axes (uf,vf,wf) of the local face coordinate system
        uf = np.array([1,0,0])
        vf = np.array([0,1,0])
        #wf = facn[f] @ xfmf # This must be (0,0,1), matching the face normal in the local coordinate system
        
        # Vertex coordinates in the local coordinate system, centered at the face barycenter
        vA = vtx[fac[f,0]] @ rotf
        vB = vtx[fac[f,1]] @ rotf
        vC = vtx[fac[f,2]] @ rotf
        
        # Normals in the local coordinate system
        nA = vtxn[fac[f,0]] @ rotf
        nB = vtxn[fac[f,1]] @ rotf
        nC = vtxn[fac[f,2]] @ rotf
        
        # Edges (coordinate of one vertex in relation to the other)
        # computed clockwise
        eA = vC - vB  # V_{i}
        eB = vA - vC  # V_{i+1} for vA
        eC = vB - vA  # V_{i+1} for vB when cycling back
        
        # Let's call our second fundamental tensor or Weingarten matrix as II.
        # II = [E F; F G], per Equation 1 of the Rusinkiewicz (2004) paper.
        # We have 3 unknowns, E, F, and G, which we can find via least squares.
        # Expanding the terms of the unnamed Figure/Equation between
        # Equations 5 and 6 of the Rusinkiewicz paper:
        # E*eA*u + F*eA*v = (nC-nB)*u
        # F*eA*u + G*eA*v = (nC-nB)*v
        # E*eB*u + F*eB*v = (nA-nC)*u
        # F*eB*u + G*eB*v = (nA-nC)*v
        # E*eC*u + F*eC*v = (nB-nA)*u
        # F*eC*u + G*eC*v = (nB-nA)*v
        # Reorganizing the terms for least squares:
        # eA*u*E + eA*v*F +    0*G = (nC-nB)*u
        #    0*E + eA*u*F + eA*v*G = (nC-nB)*v
        # eB*u*E + eB*v*F +    0*G = (nA-nC)*u
        #    0*E + eB*u*F + eB*v*G = (nA-nC)*v
        # eC*u*E + eC*v*F +    0*G = (nB-nA)*u
        #    0*E + eC*u*F + eC*v*G = (nB-nA)*v
        # So now we can do X*[E F G]' = y, where X has the coefficients (known),
        # [E F G]' is a column vector of unknowns, and Y have the normal
        # derivatives (also known).
        X = np.array([
                [eA@uf, eA@vf,     0],
                [    0, eA@uf, eA@vf],
                [eB@uf, eB@vf,     0],
                [    0, eB@uf, eB@vf],
                [eC@uf, eC@vf,     0],
                [    0, eC@uf, eC@vf] ])
        y = np.array([
                [(nC-nB)@uf],
                [(nC-nB)@vf],
                [(nA-nC)@uf],
                [(nA-nC)@vf],
                [(nB-nA)@uf],
                [(nB-nA)@vf] ])
        E,F,G = np.squeeze(np.linalg.lstsq(X, y, rcond=None)[0])
        IIf   = np.array([[E,F],[F,G]])
        
        # For each vertex of this face
        for v in range(3):
            
            # Reexpress IIf in terms of a plane that contains both vertex and
            # face normals, then accummulate for each of the face vertices
            # after weighting by the Voronoi area at this face
            rotfv = rotv[:,:,fac[f,v]].T @ rotf
            #rotfv = calc_rot(vtxn[fac[f,v]] @ rotf)
            #IIv[:,:,fac[f,v]] += rotfv[0:2,0:2].T @ IIf @ rotfv[0:2,0:2] * vorf[f,v]
            IIv[:,:,fac[f,v]] += rotfv[0:2,0:2] @ IIf @ rotfv[0:2,0:2].T * vorf[f,v]

    # For each vertex of the mesh
    for v in range(nvtx):
        
        # Normalize the accummulated IIv by the total Voronoi area of this vertex
        IIv[:,:,v] /= vorv[v]
        
        # Compute principal curvatures and their directions (eigenvalues and eigenvectors)
        kvals, kdirs = np.linalg.eig(IIv[:,:,v])

        # Put back in the global coordinate system, from the vertex local coordinate system
        kdirs = np.vstack((kdirs, np.zeros((1,2)))).T
        kdirs = kdirs @ rotv[:,:,v].T
        
        # Annoyingly, and after many hours debugging, np.linalg.eig does not return
        # eigenvalues and eigenvectors in any particular order. Let's sort them...
        idx = np.argsort(kvals)[::-1] # sort in descending order
        
        # Store principal curvatures for subsequent saving
        k1[v]    = kvals[idx[0]]
        k2[v]    = kvals[idx[1]]
        kd1[v,:] = kdirs[idx[0],:]
        kd2[v,:] = kdirs[idx[1],:]

    return k1, k2, kd1, kd2

if __name__ == "__main__":

    # Argument parsing
    parser = argparse.ArgumentParser(description="Compute curvatures from a Wavefront OBJ file.")
    parser.add_argument('--in',  dest='input',     required=True, help="Input Wavefront OBJ file")
    parser.add_argument('--it',  dest='intype',    default=None,  help="Input type (file format)")
    parser.add_argument('--ot',  dest='outtype',   default=None,  help="Output type (file format)")
    parser.add_argument('--out', dest='outprefix', required=True, help="Prefix for output curvature files")
    args = parser.parse_args()
    
    # Read Wavefront OBJ
    print('Reading input file: {}'.format(args.input))
    surfs = ('surf', 'pial', 'white', 'inflated', 'sphere', 'sphere.reg', 'orig')
    if args.intype.lower() == 'obj' or args.input.lower().endswith('obj'):
        obj = read_obj(args.input)
        vtx = obj['v']
        fac = obj['f']
    elif args.intype.lower() == 'surf' or args.input.lower().endswith(surfs):
        vtx, fac = nib.freesurfer.read_geometry(args.input)
    
    # Compute vertex normals
    print('Computing face and vertex normals using the Max (1999) algorithm')
    vtxn, facn = calc_normals(vtx, fac)
    
    # Compute Voronoi areas
    print('Computing Voronoi areas per vertex at each face')
    vorv, vorf, area = calc_voronoi_areas(vtx, fac)
    
    # Compute principal curvatures
    print('Computing principal curvatures using the Rusinkiewicz (2004) algorithm')
    k1, k2, kd1, kd2 = calc_curvatures(vtx, fac, vtxn, facn, vorv, vorf)

    # Save results
    print('Saving results with prefix: {}'.format(args.outprefix))
    if args.outtype.lower() == 'asc' or args.outtype.lower() == 'dpv':
        
        # ASCII (asc or dpv)
        filek1 = '{}.k1.{}'.format(args.outprefix, args.outtype.lower())
        filek2 = '{}.k2.{}'.format(args.outprefix, args.outtype.lower())
        write_curv(filek1, k1, kd1)
        write_curv(filek2, k2, kd2)
    
    elif args.outtype.lower() == 'curv':
        
        # FreeSurfer curvature format
        filek1 = '{}.k1'.format(args.outprefix)
        filek2 = '{}.k2'.format(args.outprefix)
        nib.freesurfer.io.write_morph_data(filek1, np.asarray(k1, dtype=np.float32))
        nib.freesurfer.io.write_morph_data(filek2, np.asarray(k2, dtype=np.float32))
        
    elif args.outtype.lower() == 'mgh' or args.outtype.lower() == 'mgz':
        
        # FreeSurfer voxelwise format (mgh/mgz)
        filek1 = '{}.k1.{}'.format(args.outprefix, args.outtype.lower())
        filek2 = '{}.k2.{}'.format(args.outprefix, args.outtype.lower())
        affine = np.eye(4)
        mgh    = nib.MGHImage(np.asarray(k1, dtype=np.float32).reshape(-1, 1, 1), affine)
        nib.save(mgh, filek1)
        mgh    = nib.MGHImage(np.asarray(k2, dtype=np.float32).reshape(-1, 1, 1), affine)
        nib.save(mgh, filek2)
        
    print('Done')