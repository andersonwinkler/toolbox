#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Mar  7 22:36:30 2025

@author: winkleram
"""

import argparse
import numpy as np
import nibabel as nib

def read_obj(filein): # =======================================================
    '''
    Open and parse a Wavefront OBJ file.
    Handles all standard face formats and returns texture/normal indices.
    
    Parameters:
    filein (str): Path to the OBJ file
    
    Returns:
    dict: Dictionary containing vertices, normals, texture coordinates, and faces
          with their respective vertex, texture, and normal indices
    '''
    v  = []
    vt = []
    vn = []
    f  = []
    ft = []
    fn = []
    with open(filein, 'r') as fp:
        for line in fp:
            if line.startswith('#'):  # Skip comments
                continue
            values = line.split()
            if not values:
                continue
            if values[0] == 'v':     # Vertex coordinates
                v.append([float(x) for x in values[1:4]])
            elif values[0] == 'vt':  # Texture coordinates
                vt.append([float(x) for x in values[1:3]])
            elif values[0] == 'vn':  # Normals
                vn.append([float(x) for x in values[1:4]])
            elif values[0] == 'f':  # Face
                vidx  = []
                vtidx = []
                vnidx = []
                for val in values[1:]:
                    idx = val.split('/')
                    vidx.append(int(idx[0]) - 1)
                    if len(idx) > 1 and idx[1]: # Texture coordinate index
                        vtidx.append(int(idx[1]) - 1)
                    else:
                        vtidx.append(None)
                    if len(idx) > 2: # Normal coordinate index
                        vnidx.append(int(idx[2]) - 1)
                    else:
                        vnidx.append(None)
                f.append(vidx)
                ft.append(vtidx)
                fn.append(vnidx)
            elif values[0] == 's':
                continue
    obj = {
        'v':  np.array(v),   # Vertex coords
        'vt': np.array(vt),  # Vertex texture
        'vn': np.array(vn),  # Vertex normal
        'f':  np.array(f),   # Face indices (refer to v)
        'ft': np.array(ft),  # Face texture indices (refer to vt)
        'fn': np.array(fn)   # Face normal indices (refer to vn)
    }
    return obj

def write_curv(fileout, k, kd): # =============================================
    '''
    Write a FreeSurfer curvature file in ASCII format 
    aka, dpv, data-per-vertex).
    
    Parameters
    ----------
    fileout : String
        Filename of the output.
    k : NumPy vector
        Curvature (e.g., k1, k2 vertexise).
    kd : NumPy array with 3 columns.
        Direction of the curvature.

    Returns
    -------
    None.
    '''
    nvtx = k.shape[0]
    idx = np.arange(0,nvtx)[:,None]
    data = np.concatenate((idx,kd,k[:,None]), axis=1)
    np.savetxt(fileout, data, fmt='%d %f %f %f %f')
    return

def calc_normals(vtx, fac): # =================================================
    '''
    Compute vertex and face normals.
    
    Parameters
    ----------
    vtx : NumPy array with 3 columns (float).
        Vextex coordinates.
    fac : NumPy array with 3 columns (int).
        Face indices.

    Returns
    -------
    vn : NumPy array with 3 columns (float).
        Vertex normals.
    fn : NumPy array with 3 columns (float).
        Face normals.
    '''
    
    # Number of vertices and faces
    nvtx = vtx.shape[0]
    nfac = fac.shape[0]
    
    # Allocate to accumulate vertex normals
    vn = np.zeros((nvtx, 3))
    fn = np.zeros((nfac, 3))
    
    # For each face
    for f in range(nfac):
        
        # Vertices and edges of the current face
        vA = vtx[fac[f,0]]
        vB = vtx[fac[f,1]]
        vC = vtx[fac[f,2]]
        eA = vC - vB  # V_{i}
        eB = vA - vC  # V_{i+1} for vA
        eC = vB - vA  # V_{i+1} for vB when cycling back
                
        # Edge lengths
        len_eA = np.linalg.norm(eA)
        len_eB = np.linalg.norm(eB)
        len_eC = np.linalg.norm(eC)
        
        # Face normal
        fn[f,:] = np.cross(eC, eA)

        # Angles at each vertex, clip to avoid numerical problems
        cos_alphaA = np.clip(np.dot(eC, -eB) / (len_eC * len_eB), -1.0, 1.0)
        cos_alphaB = np.clip(np.dot(eA, -eC) / (len_eA * len_eC), -1.0, 1.0)
        cos_alphaC = np.clip(np.dot(eB, -eA) / (len_eB * len_eA), -1.0, 1.0)
        alphaA     = np.arccos(cos_alphaA)
        alphaB     = np.arccos(cos_alphaB)
        alphaC     = np.arccos(cos_alphaC)
        
        # Weights -- Equation 2 of Max (1999), i.e., sin(alpha) / (|V_i| * |V_{i+1}|)
        cA = np.sin(alphaA) / (len_eB * len_eC)
        cB = np.sin(alphaB) / (len_eA * len_eC)
        cC = np.sin(alphaC) / (len_eA * len_eB)

        # Accumulate weighted face normal contributions
        # thus avoiding to iterate over vertices
        vn[fac[f,0]] += cA * fn[f]
        vn[fac[f,1]] += cB * fn[f]
        vn[fac[f,2]] += cC * fn[f]

    # Normalize normals to unit norm
    vn  /= np.linalg.norm(vn, axis=1)[:,None]
    fn  /= np.linalg.norm(fn, axis=1)[:,None]
    return vn, fn

def calc_voronoi_areas(vtx, fac): # ===========================================
    '''
    Compute the Voronoi areas for each vertex and, within a face, for each
    vertex of that face.

    Parameters
    ----------
    vtx : NumPy array with 3 columns (float).
        Vextex coordinates.
    fac : NumPy array with 3 columns (int).
        Face indices.

    Returns
    -------
    vorv : NumPy vector (float)
        Voronoi area per vertex.
    vorf : NumPy array with 3 columns (float).
        Voronoi area per vertex per face.
    area : NumPy vector (float)
        Area per face

    Note that np.sum(vorf, axis=1) is the same as area, whereas vorv contains
    the sum of all values in vorf for that vertex (referenced by fac).
    '''
    
    # Number of vertices and faces
    nvtx = vtx.shape[0]
    nfac = fac.shape[0]
    
    # Allocate to store Voronoi areas, per vertex and per vertex of each face
    area = np.zeros(nfac)
    vorv = np.zeros(nvtx)
    vorf = np.zeros((nfac, 3))
    
    # For each face
    for f in range(nfac):
        
        # Vertices and edges of the current face
        vA = vtx[fac[f,0]]
        vB = vtx[fac[f,1]]
        vC = vtx[fac[f,2]]
        eA = vC - vB  # V_{i}
        eB = vA - vC  # V_{i+1} for vA
        eC = vB - vA  # V_{i+1} for vB when cycling back
                
        # Edge lengths
        len_eA = np.linalg.norm(eA)
        len_eB = np.linalg.norm(eB)
        len_eC = np.linalg.norm(eC)

        # Angles at each vertex, clip to avoid numerical problems
        cos_alphaA = np.clip(np.dot(eC, -eB) / (len_eC * len_eB), -1.0, 1.0)
        cos_alphaB = np.clip(np.dot(eA, -eC) / (len_eA * len_eC), -1.0, 1.0)
        cos_alphaC = np.clip(np.dot(eB, -eA) / (len_eB * len_eA), -1.0, 1.0)
        alphaA     = np.arccos(cos_alphaA)
        alphaB     = np.arccos(cos_alphaB)
        alphaC     = np.arccos(cos_alphaC)
        
        # Area of the entire face
        area[f] = np.linalg.norm(np.cross(eA, eB))/2

        # Voronoi area for each vertex of a face
        # Voronoi area = (angle / sum of angles) * area
        vorA     = area[f] * alphaA / np.pi
        vorB     = area[f] * alphaB / np.pi
        vorC     = area[f] * alphaC / np.pi
        vorf[f,:] = [vorA, vorB, vorC]
        
        # Accumulate vertex Voronoi areas for faces that meet at that vertex
        for v in range(3):
            vorv[fac[f,v]] += vorf[f,v]
    return vorv, vorf, area

def calc_rot(n): # ============================================================
    '''
    Compute a 3x3 rotation matrix that changes the coordinate system such
    that n @ rot is a new coordinate system with the z-axis along n.

    Parameters
    ----------
    n : Input vector, already with norm = 1

    Returns
    -------
    rot : Rotation matrix
    '''
    n     /= np.linalg.norm(n)
    z      = np.array([0,0,1])
    axis   = np.cross(z,n)
    naxis  = np.linalg.norm(axis)
    if naxis > 0:
        axis  /= naxis
    angle  = np.arccos(np.clip(np.dot(z,n),-1,1))
    K = np.array([
        [   0 ,    -axis[2],  axis[1]],
        [ axis[2],       0 , -axis[0]],
        [-axis[1],  axis[0],       0]])
    rot    = np.eye(3) + np.sin(angle) * K + (1 - np.cos(angle)) * (K @ K)
    return rot

def calc_curvatures(vtx, fac, vtxn, facn, vorv, vorf): # ======================
    '''
    Compute curvatures k1 and k2 following the algorithm proposed by
    Rusinkiewicz (2004), as well as the corresponding directions.

    Parameters
    ----------
    vtx : NumPy array with 3 columns (float).
        Vextex coordinates.
    fac : NumPy array with 3 columns (int).
        Face indices.
    vtxn : NumPy array with 3 columns (float).
        Vertex normals.
    facn : NumPy array with 3 columns (float).
        Face normals.
    vorv : NumPy vector (float)
        Voronoi area per vertex.
    vorf : NumPy array with 3 columns (float).
        Voronoi area per vertex per face.

    Returns
    -------
    k1 : NumPy vector (float)
        Curvature k1.
    k2 : NumPy vector (float)
        Curvature k2.
    kd1 : NumPy array with 3 columns (float).
        Direction of curvature k1.
    kd2 : NumPy array with 3 columns (float).
        Direction of curvature k2.
    '''
    
    # Number of vertices and faces
    nvtx = vtx.shape[0]
    nfac = fac.shape[0]
    
    # Precompute transforms from the global to local coordinate system of each vertex
    rotv = np.zeros((3,3,nvtx))
    for v in range(nvtx):
       rotv[:,:,v] = calc_rot(vtxn[v])
    
    # Allocate space to store the Weingarten matrix for each vertex
    IIv = np.zeros((2,2,nvtx))
    
    # Allocate soace to store k1, k2, and the directions kd1 and kd2
    k1  = np.zeros(nvtx)
    k2  = np.zeros(nvtx)
    kd1 = np.zeros((nvtx,3))
    kd2 = np.zeros((nvtx,3))

    # For each face
    for f in range(nfac):

        # Transformation from the global the local coordinate system of this face
        rotf = calc_rot(facn[f])

        # Axes (uf,vf,wf) of the local face coordinate system
        uf = np.array([1,0,0])
        vf = np.array([0,1,0])
        
        # Confirm that the face normal matches the z of the coordinate system.
        # This must be (0,0,1); uncomment to test
        # print(facn[f] @ rotf)
        
        # Vertex coordinates in the local coordinate system, centered at the face barycenter
        vA = vtx[fac[f,0]] @ rotf
        vB = vtx[fac[f,1]] @ rotf
        vC = vtx[fac[f,2]] @ rotf
        
        # Normals in the local coordinate system
        nA = vtxn[fac[f,0]] @ rotf
        nB = vtxn[fac[f,1]] @ rotf
        nC = vtxn[fac[f,2]] @ rotf
        
        # Edges (coordinate of one vertex in relation to the other)
        # computed clockwise
        eA = vC - vB  # V_{i}
        eB = vA - vC  # V_{i+1} for vA
        eC = vB - vA  # V_{i+1} for vB when cycling back
        
        # Let's call our second fundamental tensor or Weingarten matrix as II.
        # II = [E F; F G], per Equation 1 of the Rusinkiewicz (2004) paper.
        # We have 3 unknowns, E, F, and G, which we can find via least squares.
        # Expanding the terms of the unnamed Figure/Equation between
        # Equations 5 and 6 of the Rusinkiewicz paper:
        # E*eA*u + F*eA*v = (nC-nB)*u
        # F*eA*u + G*eA*v = (nC-nB)*v
        # E*eB*u + F*eB*v = (nA-nC)*u
        # F*eB*u + G*eB*v = (nA-nC)*v
        # E*eC*u + F*eC*v = (nB-nA)*u
        # F*eC*u + G*eC*v = (nB-nA)*v
        # Reorganizing the terms for least squares:
        # eA*u*E + eA*v*F +    0*G = (nC-nB)*u
        #    0*E + eA*u*F + eA*v*G = (nC-nB)*v
        # eB*u*E + eB*v*F +    0*G = (nA-nC)*u
        #    0*E + eB*u*F + eB*v*G = (nA-nC)*v
        # eC*u*E + eC*v*F +    0*G = (nB-nA)*u
        #    0*E + eC*u*F + eC*v*G = (nB-nA)*v
        # So now we can do X*[E F G]' = y, where X has the coefficients (known),
        # [E F G]' is a column vector of unknowns, and Y has the normal
        # differences (also known).
        X = np.array([
                [eA@uf, eA@vf,     0],
                [    0, eA@uf, eA@vf],
                [eB@uf, eB@vf,     0],
                [    0, eB@uf, eB@vf],
                [eC@uf, eC@vf,     0],
                [    0, eC@uf, eC@vf] ])
        y = np.array([
                [(nC-nB)@uf],
                [(nC-nB)@vf],
                [(nA-nC)@uf],
                [(nA-nC)@vf],
                [(nB-nA)@uf],
                [(nB-nA)@vf] ])
        E,F,G = np.squeeze(np.linalg.lstsq(X, y, rcond=None)[0])
        IIf   = np.array([[E,F],[F,G]])
        
        # For each vertex of this face
        for v in range(3):
            
            # Reexpress IIf in terms of the vertex coordinate system.
            # First we define a matrix to "unrotate" the local coordinate system 
            # from the face back to the global and then to the vertex.            
            rotfv = rotf.T @ rotv[:,:,fac[f,v]]
            
            # Confirm that the vertex normal in the face local coordinate system
            # is successfully rotated so that it matches the z of the vertex coordinate system.
            # This must be (0,0,1); uncomment to test
            # print(vtxn[fac[f,v]] @ rotf @ rotfv)
            
            # Then we reexpress the tensor in the vertex local coordinate system
            # and weight it by the Voronoi area of this vertex at this face.
            IIv[:,:,fac[f,v]] += rotfv[0:2,0:2].T @ IIf @ rotfv[0:2,0:2] * vorf[f,v]
            
    # For each vertex of the mesh
    for v in range(nvtx):
        
        # Normalize the accummulated IIv by the total Voronoi area of this vertex
        IIv[:,:,v] /= vorv[v]
        
        # Compute principal curvatures and their directions (eigenvalues and eigenvectors)
        kvals, kdirs = np.linalg.eig(IIv[:,:,v])

        # Put back in the global coordinate system, from the vertex local coordinate system
        kdirs = np.vstack((kdirs, np.zeros((1,2)))).T
        kdirs = kdirs @ rotv[:,:,v].T
        
        # Annoyingly, and after many hours debugging, np.linalg.eig does not return
        # eigenvalues and eigenvectors in any particular order. Let's sort them...
        idx = np.argsort(kvals)[::-1] # sort in descending order
        
        # Store principal curvatures for subsequent saving
        k1[v]    = kvals[idx[0]]
        k2[v]    = kvals[idx[1]]
        kd1[v,:] = kdirs[idx[0],:]
        kd2[v,:] = kdirs[idx[1],:]
        
        # Confirm that the two principal directions are orthogonal to the normal
        # at this vertex. These two values must be zero; uncomment to test
        # print(np.dot(kd1[v,:],vtxn[v,:]), np.dot(kd2[v,:],vtxn[v,:]))
        
    return {'k1':k1, 'k2':k2, 'kdir1':kd1, 'kdir2':kd2}

def calc_composites(curvs): # ================================================
    
    # Gaussian curvature
    curvs['K']    = curvs['k1']*curvs['k2']
    
    # Mean curvature
    curvs['H']    = (curvs['k1']+curvs['k2'])/2
    
    # Curvature difference
    curvs['diff'] = curvs['k1'] - curvs['k2']
    
    # Intrinsic Curvature Index (ICI, NICI, AICI)
    curvs['ICI']   = np.maximum(curvs['K'],0)
    curvs['NICI']  = np.maximum(curvs['K'],0) # Negative version
    curvs['AICI']  = np.absolute(curvs['K'])  # Absolute version
    
    # Mean Curvature Index (ICI, NICI, AICI)
    curvs['MCI']   = np.maximum(curvs['H'],0)
    curvs['NMCI']  = np.maximum(curvs['H'],0) # Negative version
    curvs['AMCI']  = np.absolute(curvs['H'])  # Absolute version
    
    # Gauss Curvature L^2 Norm (GLN)
    curvs['GLN']   = curvs['K']**2
    
    # Mean Curvature L^2 Norm (MLN)
    curvs['MLN']   = curvs['H']**2
    
    # Folding Index
    curvs['FI']    = np.absolute(curvs['k1']) * (np.absolute(curvs['k1']) - np.absolute(curvs['k2']))
    
    # Curvedness Index
    curvs['CI']    = np.sqrt(curvs['k1']**2 + curvs['k2']**2)/np.sqrt(2)
    
    # Shape Index
    curvs['SI']    = 2*np.arctan((curvs['k1']+curvs['k2'])/(curvs['k1']-curvs['k2']))/np.pi
    
    # Area Fraction of Intrinsic Curvature Index
    curvs['FICI']  = (curvs['K'] > 0).astype(float)
    curvs['FNICI'] = (curvs['K'] > 0).astype(float)
    
    # Area Fraction of Mean Curvature Index
    curvs['FMCI']  = (curvs['H'] > 0).astype(float)
    curvs['FNMCI'] = (curvs['H'] > 0).astype(float)
    
    # SH2SH and SK2SK
    curvs['SK2SK'] = curvs['GLN'] / curvs['AICI']
    curvs['SH2SH'] = curvs['MLN'] / curvs['AMCI']
    
    return curvs

if __name__ == "__main__":

    # Argument parsing
    parser = argparse.ArgumentParser(description="Compute curvatures from a Wavefront OBJ file.")
    parser.add_argument('--in',  dest='input',     required=True, help="Input Wavefront OBJ file")
    parser.add_argument('--it',  dest='intype',    default=None,  help="Input type (file format)")
    parser.add_argument('--ot',  dest='outtype',   default=None,  help="Output type (file format)")
    parser.add_argument('--out', dest='outprefix', required=True, help="Prefix for output curvature files")
    args = parser.parse_args()
    
    # Read Wavefront OBJ
    print('Reading input file: {}'.format(args.input))
    surfs = ('surf', 'pial', 'white', 'inflated', 'sphere', 'sphere.reg', 'orig')
    if args.intype.lower() == 'obj' or args.input.lower().endswith('obj'):
        obj = read_obj(args.input)
        vtx = obj['v']
        fac = obj['f']
    elif args.intype.lower() == 'surf' or args.input.lower().endswith(surfs):
        vtx, fac = nib.freesurfer.read_geometry(args.input)
    
    # Compute vertex normals
    print('Computing face and vertex normals using the Max (1999) algorithm')
    vtxn, facn = calc_normals(vtx, fac)
    
    # Compute Voronoi areas
    print('Computing Voronoi areas per vertex at each face')
    vorv, vorf, area = calc_voronoi_areas(vtx, fac)
    
    # Compute principal curvatures
    print('Computing principal curvatures using the Rusinkiewicz (2004) algorithm')
    curvs = calc_curvatures(vtx, fac, vtxn, facn, vorv, vorf)
    
    # Compute composite measures based on k1 and k2
    print('Computing composite curvatures from the principal curvatures')
    curvs = calc_composites(curvs)
    
    # Save results
    print('Saving results with prefix: {}'.format(args.outprefix))
    if args.outtype.lower() == 'asc' or args.outtype.lower() == 'dpv':
        
        # ASCII (asc or dpv)
        for c in curvs:
            filename = '{}.{}.{}'.format(args.outprefix, c, args.outtype.lower())
            if c == 'k1':
                dirs = curvs['kdir1']
            elif c == 'k2':
                dirs = curvs['kdir2']
            elif c in ['kdir1', 'kdir2']:
                continue
            else:
                dirs = np.zeros((curvs[c].shape[0],3))
            write_curv(filename, curvs[c], dirs)
            
    elif args.outtype.lower() == 'curv':
        
        # FreeSurfer curvature format
        for c in curvs:
            filename = '{}.{}'.format(args.outprefix, c)
            if c in ['kdir1', 'kdir2']:
                continue
            nib.freesurfer.io.write_morph_data(filename, np.asarray(curvs[c], dtype=np.float32))
        
    elif args.outtype.lower() == 'mgh' or args.outtype.lower() == 'mgz':
        
        # FreeSurfer voxelwise format (mgh/mgz)
        affine = np.eye(4)
        for c in curvs:
            filename = '{}.{}.{}'.format(args.outprefix, c, args.outtype.lower())
            if c in ['kdir1', 'kdir2']:
                continue
            mgh = nib.MGHImage(np.asarray(curvs[c], dtype=np.float32).reshape(-1, 1, 1), affine)
            nib.save(mgh, filename)
        
    print('Done')