function varargout = gentraits(varargin)
% Generate a set of random quantitative traits with specified
% between-subject and between-trait correlation structure, as
% generated by a multivariate normal process with K known
% covariance terms.
%
% There are two ways of calling this function and generating the
% traits:
%
% Y = gentraits(G,E,pidxfile,phi2file,phenfile,noise);  % Way 1
% Y = gentraits(R,S,X,beta,id,phenfile,xfile,noise);    % Way 2
%
% In either of these calls, the result is the same: a set of
% correlated traits.
%
% Inputs (Way 1):
% G        : G matrix with the desired genetic correlations, all
%            standardized by the phenotypic variance. G can be spe-
%            cified as a vector with only the heritabilities, in which
%            case the traits will have no genetic correlation.
% E        : E matrix with the desired environmental correlations.
%            Note that diag(E) + diag(G) must be equal to a vector
%            of ones. Leave this argument empty [ ] to use a diagonal
%            matrix 1-diag(G) as default.
% pidxfile : CSV file containing the subject and indices.
% phi2file : CSV file containing the phi2 matrix.
%            Both pedigree CSV files can be generated with the
%           'ped2csv' shell script.
% phenfile : CSV file to be created containing the traits.
% noise    : Distribution for the noise. It can be 'Laplace', 'Weibull'
%            or anything else for 'Gaussian'.
%
% Inputs (Way 2):
% R        : Cell with K elements, each one being a T by T correlation
%            matrix, where T is the number of traits being created.
% S        : Cell with K elements, each one being an N by N correlation
%            matrix, where N is the number of subjects.
% X        : Design matrix with covariates to be added to the traits
%            once their covariance structure (between-subject and
%            between-trait) has been simulated. Hence, the covariates
%            are not assumed to have the same covariance structure as
%            provided by any of the K covariance terms. X can be a matrix
%            with N rows, in which case the same covariates are used for
%            all traits, or a cell array with T elements, in which case
%            each trait can have it's own covariate structure.
% b        : Betas for the columns of X. It's structure should pair with
%            what is in X.
% id       : Optional. Cell with N elements, each being the ID for the
%            subjects. Strings or integers are valid as ID.
% phenfile : Optional. Phenotype file to be created.
% xfile    : Optional. Design matrix file for the covariates to be saved.
% noise    : Distribution for the noise. It can be 'Laplace', 'Weibull'
%            or anything else for 'Gaussian'.
%
% Outputs:
% Y        : Phenotype (values only, without subject IDs or trait names).
%
% Observations:
% - Both G and E, as well as all the K components of R and S must be
%   symmetric, positive-definite.
% - The off-diagonal elements of G are the same as the
%   Endophenotypic Ranking Value (ERV).
%
% _____________________________________
% Anderson M. Winkler
% FMRIB / University of Oxford
% Dec/2011 (first version)
% Jan/2012 (this version)
% http://brainder.org

% Parameter for the Weibull distribution
kpar = 3;

% Choose which way to go
if nargin < 5 || nargin > 8,
    error('Invalid number of arguments');
    
elseif ischar(varargin{3}) && ischar(varargin{4}), % Way 1, less generic
    
    % Accept arguments
    fields = {'G','E','pidxfile','phi2file','phenfile','noise'};
    for a = 1:nargin,
        v.(fields{a}) = varargin{a};
    end
    if length(v.G) == numel(v.G); v.G = diag(v.G); end
    if isempty(v.E), v.E = diag(1-diag(v.G)); end
    if any(diag(v.G) + diag(v.E) - 1 > eps),
        v.E = v.E - diag(diag(v.E));
        v.E = v.E + diag(1-diag(v.G));
    end
    
    % Load pedigree and init some vars for later
    fprintf('Loading pedigree... ')
    ped  = loadped(v.pidxfile,v.phi2file);
    fprintf('done\n')
    nS = size(ped.pidx,1);
    nT = size(v.G,1);
    v.id = ped.id;
    
    % Create the traits
    fprintf('Simulating traits... ')
    indeptrt = false;
    tmp = v.G - diag(diag(v.G));
    if abs(sum(tmp(:))) <= eps,
        indeptrt = true;
    end
    clear tmp;
    if indeptrt,
        if strcmpi(v.noise,'weibull'),
            Y = (wblrnd(1,1/kpar,nS,nT)-gamma(1+kpar))./(sqrt(gamma(1+2*kpar)-gamma(1+kpar)^2));
        elseif strcmpi(v.noise,'laplace'),
            Y = randlap([nS nT]);
        else
            Y = randn(nS,nT);
        end
        for t = 1:nT,
            Omega = v.G(t,t)*ped.phi2 + (1-v.G(t,t))*eye(size(ped.phi2));
            R = chol(Omega);
            Y(:,t) = R' * Y(:,t);
        end
    else
        if strcmpi(v.noise,'weibull'),
            Y = (wblrnd(1,1/kpar,nS*nT,1)-gamma(1+kpar))./(sqrt(gamma(1+2*kpar)-gamma(1+kpar)^2));
        elseif strcmpi(v.noise,'laplace'),
            Y = randlap([nS*nT 1]);
        else
            Y = randn(nS*nT,1);
        end
        Omega = kron(v.G,ped.phi2) + ...
            kron(v.E,eye(size(ped.phi2)));
        R = chol(Omega);
        Y = R' * Y;
        Y = reshape(Y,[nS nT]);
    end
    fprintf('done\n');
    
else  % Way 2, more generic
    
    % Accept arguments
    fields = {'R','S','X','b','id','phenfile','xfile','noise'};
    for a = 1:nargin,
        v.(fields{a}) = varargin{a};
    end
    for a = nargin+1:numel(fields),
        v.(fields{a}) = [];
    end
    nK = numel(v.R);
    nT = size(v.R{1},1);
    nS = size(v.S{1},1);
    
    % Create normal noise and add covariance structure
    fprintf('Simulating traits... ')
    indeptrt = false(nK,1);
    for k = 1:nK,
        tmp = v.R{k} - diag(diag(v.R{k}));
        if abs(sum(tmp(:))) <= eps,
            indeptrt(k) = true;
        end
    end
    clear tmp;
    if indeptrt,
        if strcmpi(v.noise,'weibull'),
            Y = (wblrnd(1,1/kpar,nS,nT)-gamma(1+kpar))./(sqrt(gamma(1+2*kpar)-gamma(1+kpar)^2));
        elseif strcmpi(v.noise,'laplace'),
            Y = randlap([nS nT]);
            %Y = bsxfun(@minus,Y,mean(Y,1));
        else
            Y = randn(nS,nT);
            %Y = bsxfun(@minus,Y,mean(Y,1));
        end
        for t = 1:nT,
            Omega = zeros(nS);
            for k = 1:nK,
                Omega = Omega + v.R{k}(t,t)*v.S{k};
            end
            R = chol(Omega);
            Y(:,t) = R' * Y(:,t);
        end
    else
        if strcmpi(v.noise,'weibull'),
            Y = (wblrnd(1,1/kpar,nS*nT,1)-gamma(1+kpar))./(sqrt(gamma(1+2*kpar)-gamma(1+kpar)^2));
        elseif strcmpi(v.noise,'laplace'),
            %Y = randlap([nS nT]);
            %Y = bsxfun(@minus,Y,mean(Y,1));
            %Y = Y(:);
            Y = randlap([nS*nT 1]);
        else
            %Y = randn(nS,nT);
            %Y = bsxfun(@minus,Y,mean(Y,1));
            %Y = Y(:);
            Y = randn(nS*nT,1);
        end
        Omega = zeros(nS*nT*[1 1]);
        for k = 1:nK,
            Omega = Omega + kron(v.R{k},v.S{k});
        end
        R = chol(Omega);
        Y = R' * Y;
        Y = reshape(Y,[nS nT]);
    end
    
    % Add the covariates
    if ~isempty(v.X) && ~isempty(v.b),
        if iscell(v.X) && iscell(v.b);
            for t = 1:nT,
                Y(:,t) = Y(:,t) + v.X{t}*v.b{t};
            end
        else
            Y = bsxfun(@plus,Y,v.X*v.b);
        end
    end
    fprintf('done\n');
end

% Create names/headers and save traits
if ~ isempty(v.phenfile),
    
    fprintf('Saving traits... ')
    headers = cell(1,nT+1);
    headers{1} = 'id';
    for t = 1:nT,
        headers{t+1} = sprintf('trt_%0.5d',t);
    end
    T2save = cell(size(Y) + [1 1]);
    T2save(1,:) = headers;
    T2save(2:size(T2save,1),1) = v.id(:);
    T2save(2:size(T2save,1),2:size(T2save,2)) = num2cell(Y);
    cellcsvwrite(T2save,v.phenfile);
    fprintf('done!\n')
end

% Create names/headers and save covariates design matrix
if isfield(v,'xfile') && ~isempty(v.xfile),
    
    fprintf('Saving covariates file... ')
    [fpth,fnam,fext] = fileparts(v.xfile);
    if ~ strcmpi(fext,'.csv'),
        fnam = sprintf('%s%s',fnam,fext);
        fext = '.csv';
    end
    if iscell(v.X),
        for t = 1:nT,
            fnamT = sprintf('%s_%0.2d%s',fnam,t,fext);
            nEV = size(v.X{t},2);
            headers = cell(1,nEV+1);
            headers{1} = 'id';
            for ev = 1:nEV,
                headers{ev+1} = sprintf('EV_%0.5d',ev);
            end
            X2save = cell(size(v.X{t}) + [1 1]);
            X2save(1,:) = headers;
            X2save(2:size(X2save,1),1) = v.id(:);
            X2save(2:size(X2save,1),2:size(X2save,2)) = num2cell(v.X{t});
            cellcsvwrite(X2save,fullfile(fpth,fnamT));
        end
    else
        nEV = size(v.X,2);
        headers = cell(1,nEV+1);
        headers{1} = 'id';
        for ev = 1:nEV,
            headers{ev+1} = sprintf('EV_%0.5d',ev);
        end
        X2save = cell(size(v.X) + [1 1]);
        X2save(1,:) = headers;
        X2save(2:size(X2save,1),1) = v.id(:);
        X2save(2:size(X2save,1),2:size(X2save,2)) = num2cell(v.X);
        cellcsvwrite(X2save,fullfile(fpth,[fnam fext]));
    end
    fprintf('done!\n')
end

% Leave a copy in the workspace if needed
varargout{1} = Y;
